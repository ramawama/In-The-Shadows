In The Shadows
By Rama Janco, Deven Ellis, Ryan Lewis, Jason Baron, and Carson Sobolewski

Below are the reasonings for why we believe our code deserves points for each category in the rubric.


### INTERFACE ###

Element Visibility: We believe all of the elements

Element Usability: We believe all of the elements are usable

Intuitiveness: We believe all of the elements are intuitive

Consistency: We believe all of the elements are consistent

Status Visibility: We believe all of the elements are visible


### NAVIGATION ###

Mechanics / API: We believe all of the elements are findable because

Tested / Not Buggy: We believe all of the elements are thoroughly and not buggy tested because

Minimal Acclimation: We believe the elements in our game require minimal acclimation because

Predictability: We believe the elements in our game are predictable because

Discoverability: We believe the elements in our game are discoverable because


### USER PERCEPTION ###

Enjoyability: We believe our game is enjoyable because

Minimal Frustration: We believe our game is minimally frustrating because

General Usability: We believe our game is generally usable because


### RESPONSIVENESS ###

Action Indications / Non-Blocking: We believe our game has a clear indicator of the action going on in the game.
This is because of the HUD we have on the bottom of out screen. The left side of the HUD tells the player if they have any abilities or items readied for them to use.

State Indications: We believe that our game has a clear indication of the state because the HUD on the bottom of the screen tells the player what state the game is in.
The right side of the HUD tells the player what the current object is and changes based on what step and level the character is on.

Task Success: We believe that our game makes it extremely clear when the player has won because the game will stop and display a message saying "You Win!".

Task failure: We believe that our game makes it extremely clear when the player has lost because the game will stop and display a message saying "Game Over".


### BUILD QUALITY ###

Robustness: We believe our game is robust because our code was written with error checking and handling in mind.
Every time any coordinates are called, they are wrapped in a try/except clause to make sure there is no way an out of bounds error can crash the game.
Additionally, we leveraged the use of predefined levels which are designed to be impossible to break because they are surrounded by walls which cannot be passed.
This results in a game where any user input cannot result in a crash from the users actions, there may be bugs from other functions that are out of the control of the player.

Consistency: We believe our game is consistent because we used a consistent naming scheme for all of our variables and functions.
These rules were enforced by a GitHub task on push so every coder had to conform to using the same scheme.

Aesthetic Rigor: We believe our game is aesthetically rigorous because we developed every single asset by hand without the use of any tools or libraries.
The animations are all done by hand as well so this is an entirely student-designed game which took an extreme amount of effort.


### FEATURES ###

Front-End: The front end of our game

Data Store: The data storage within our game

Back-End: The back end of our game